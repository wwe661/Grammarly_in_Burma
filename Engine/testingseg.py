# -*- coding: utf-8 -*-
"""TestingSeg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KhAKlI3H2g6Xv64D2s3EpbnmeVchT7Ig
"""

#@title Load Model
#Load the model aggregation_strategy = simple so 'entity_group' is pos
pos = None
def initialize_model():
    global pos
    if pos is None:
      from transformers import pipeline

      pos = pipeline("token-classification", model="chuuhtetnaing/myanmar-pos-model",aggregation_strategy="simple")

# @title normalize
# normalize text to unicode
import unicodedata

def normalize_unicode(text):
    return unicodedata.normalize("NFC", text)

# @title Validation
# loneasat is when the model split the word with "်" worngly
#the main here is valadation
Balpha = set("ကခဂဃငစဆဇဈညဋဌဍဎဏတထဒဓနပဖဗဘမယရလဝသဟဠအ၏၍၌ဩဪဢဣဤဥဦဧဨဿ၌၎။")

def loneasat(word):
  if "်" in word and len(word)<3:
    return True
  elif "်" in word[:3]:
    c = 0
    for i in word[:2]:
      if i in Balpha:
        c+=1
    return True if c<2 else False

def validate(segments):
    print("validating")
    newseg = []
    prev = ""
    for i, seg in enumerate(segments):
        word = seg["word"]

        # Default: append normally
        merged = False

        if len(word) > 0 and i > 0:

            #  Case 1: include a non-alphabet (likely broken split)
            if word[0] not in Balpha:
                print("case 1 merge →", word)

                prev = newseg.pop()
                newseg.append({
                    "entity_group": prev["entity_group"],
                    "word": prev["word"] + word,
                    "start": prev["start"],
                    "end": seg["end"]
                })
                merged = True

            #  Case 2: lonely " ်"
            elif loneasat(word):
                print("case 2 lonely ' ်'", word)

                prev = newseg.pop()
                newseg.append({
                    "entity_group": prev["entity_group"],
                    "word": prev["word"] + word,
                    "start": prev["start"],
                    "end": seg["end"]
                })
                merged = True

        #consecutive same pos or part + ppm
        if seg['entity_group'] == prev or (prev in lookfor and seg['entity_group'] in lookfor):
          temp = newseg.pop()
          newseg.append({
              "entity_group": prev,
              "word": temp['word']+word,
              "start": temp["start"],
              "end": seg["end"]
          })
          merged = True
        if not merged:
            newseg.append({
                "entity_group": seg["entity_group"],
                "word": word,
                "start": seg["start"],
                "end": seg["end"]
            })
        prev = seg['entity_group']
    return newseg

# @title Display
def display(segments,form = "entity_group"):
  result = []
  for segment in segments:
      print(segment)
      pos_tag = segment[form]
      word = segment['word']

      result.append(word + "/" + pos_tag)

  result = " ".join(result)
  print(result)

# @title token cutter
import re

def split_syllables(text):
    # Regex pattern for Myanmar syllable breaking
    pattern = r"(?:(?<!္)([က-အ])(?![္်])|[ဣဤဥဦဧဩဪဿ၌၍၏၀-၉၊။])"
    # This simplified version inserts a separator before each valid starting consonant
    # For a full implementation, refer to the sylbreak.py repository

    # Using the standard sylbreak logic:
    # A syllable starts with a consonant not preceded by a subscript and
    # not followed by 'a-That' or a subscript symbol.
    myanmar_consonant = "\u1000-\u1021"
    en_char = "a-zA-Z0-9"
    other_char = "\u1023\u1024\u1025\u1026\u1027\u1029\u102A\u103F\u104C\u104D\u104E\u104F\u1040-\u1049\u104A\u104B"
    ss_symbol = "\u1039"
    a_that = "\u103A"

    # Detailed regex implementation from sylbreak
    re_pattern = re.compile(r"((?<!%s)[%s](?![%s%s])|[%s%s])" % (ss_symbol, myanmar_consonant, a_that, ss_symbol, en_char, other_char))

    return re_pattern.sub(r" \1", text).strip().split()


def getlengram(arr, length):
    if len(arr) <= length:
        return ["".join(arr)]
    return ["".join(arr[i : i + length]) for i in range(len(arr) - length + 1)]

# @title Is it in it?
def isitinburmese(trigger,text):
  #split the text make that an array
  temp = text
  arr = split_syllables(text)
  tarr = split_syllables(trigger)
  if len(tarr) > len(arr):
    return False
  if len(tarr) >= 1:
    temp = getlengram(arr,len(tarr))
  # print(arr,tarr,text,temp)
  if trigger in temp:
    return True
  return False
  # index = text.find(trigger)
  # if index!=-1 :
  #   return True
  # return False

# @title Definition
import json

try:
    with open('Dictionary/definition.json', 'r', encoding='utf-8') as f:
        definition = json.load(f)
    print(definition)
except FileNotFoundError:
    print("File not found")
except json.JSONDecodeError:
    print("Error decoding JSON")
timeps = ["မနေ့","ယမန်","နက်ဖြန်","မနက်ဖြန်","တပေါင်းလ"]
goverb = ["သွား"]

# @title extract form definition
def extract(data, what="all"):
    results = []

    def walk(obj, inside_target=False):
        if isinstance(obj, dict):
            for k, v in obj.items():

                # Activate flag if this node is target
                new_inside = inside_target or (k == what)

                walk(v, new_inside)

        elif isinstance(obj, list):
            for item in obj:
                walk(item, inside_target)

        elif isinstance(obj, str):
            if what == "all":
                results.append(obj)
            elif inside_target:
                results.append(obj)

    walk(data)
    return results

# @title look for , get list , safe prev,jointwodict
from collections import defaultdict
lookfor = ["ppm","part",'punc','conj']

def getthelist(namelist):
  out = []
  for _ in namelist:
    temp = extract(definition,_)
    out+=temp
  return list(set(out))


def safe_prev(arr,idx, k=1):
    return arr[idx-k] if idx-k >= 0 else None
def jointwodict(groupas,a,b,ent):
  temp = {}
  temp[groupas] = ent
  temp['word'] = a['word']+b['word'] if b else a['word']
  temp['start'] = a['start']
  temp['end'] = b['end'] if b else a['end']
  return temp

#@title Phrase & Pisi detection

def Pisi(segments):
  Npidetect = ["နာမ်ပစ္စည်း","နာမ်ပုဒ်ပြောင်း"]
  Npisi = getthelist(Npidetect)
  # print(Npisi)
  adjpidetect = ["နာမဝိသေသနပုဒ်ပြောင်း"]
  adjpisi = getthelist(adjpidetect)
  # print(adjpisi)
  advpidetect = ["ကြိယာဝိသေသနပုဒ်ပြောင်း"]
  advpisi = getthelist(advpidetect)
  # print(advpisi)
  phdetect = ["ပုဒ်ဆက်"]
  phrasemaker = getthelist(phdetect)
  # print(phrasemaker)

  newseg = []
  join = False
  used = False
  for d,seg in enumerate(segments):
      word = seg["word"].strip()
      ent = seg["entity_group"]
      temp = seg
      prev = ''

      if ent not in lookfor:
          if join:
            # newseg.pop()
            join = False
            used = True
            continue
          newseg.append(temp)
      else:

        prev1 = safe_prev(segments,d,1)
        if used:
          prev1 = newseg[-1]
          used = False
        #noun pi si fix
        for j in Npisi:
          # if isitinburmese(j,word):
          if j == word:
            if "n" not in prev1['entity_group']:
              print(j)
              newseg.pop()
              temp = jointwodict('entity_group',prev1,seg,'n')
        #adj pi si fix
        for j in adjpisi:
          # if isitinburmese(j,word):
          if j == word:
            print(j)
            if "n" not in prev1['entity_group']:
              newseg.pop()
              temp = jointwodict('entity_group',prev1,seg,'adj')
        #adv pisi fix
        for j in advpisi:
          # if isitinburmese(j,word):
          if j == word:
            print(j)
            if "n" not in prev1['entity_group']:
              newseg.pop()
              temp = jointwodict('entity_group',prev1,seg,'adv')
        for j in phrasemaker:
          if j == word:
            print(j)
            next = segments[d+1]
            next['entity_group']= "n" if next['entity_group'] =="pron" else next['entity_group']
            prev= "n" if prev1['entity_group'] =="pron" else prev1['entity_group']
            print("wtf",next,prev1)
            if next['entity_group'] == prev:
              newseg.pop()
              temp = jointwodict('entity_group',prev1,seg,'n')
              temp = jointwodict('entity_group',temp,next,'n')
              join = True

        # ။/punc fix
        if word == "။":
          newseg.pop()
          temp = jointwodict('entity_group',prev1,seg,prev1['entity_group'])
        newseg.append(temp)
        # print(temp)
  return newseg

# @title sentences detection
def GetSentences(segments):
  sentdetect = ["ဝါကျဆက်","အနက်"]
  sentextr = getthelist(sentdetect)

  joints = []
  for d,seg in enumerate(segments):
    word = seg['word']
    ent = seg['entity_group']
    if ent not in lookfor:
      continue
    for trigger in sentextr:
      if isitinburmese(trigger,word):
        print(trigger)
        for i in range(1,3):
          if segments[d-i]['entity_group'] == 'v':
            joints.append(d)
            break

  start = 0
  sents = []
  for i in joints:
    sents.append({"sentence":segments[start:i],"joint":segments[i]})
    start = i+1
  sents.append({"sentence":segments[start:],"joint":None})
  for i in sents:
    if i["joint"]:
      word = "သည်။"
      st = i['sentence'][-1]['end']
      end = st+len(word)
      i['sentence'].append({'entity_group': 'part', 'word': word, 'start': st, 'end': end})

  for i in sents:
    display(i['sentence'])
    print("joint :",i['joint'])
  print(len(sents))
  return sents

#@title ADJ phrase detection
#adj + smth = ent of last part
def adjtoN(segments):
  newseg = []
  catchnext = False
  for d,seg in enumerate(segments):
    ent = seg['entity_group']
    if ent == 'adj':
      catchnext = True
      prev1 = seg
    elif catchnext:
      print(seg)
      temp = jointwodict('entity_group',prev1,seg,ent)
      newseg.pop()
      newseg.append(temp)
      catchnext = False
      continue
    newseg.append(seg)
  return newseg

#@title optimized wibet detection
def match_trigger(word, trigger_list):
    return next((t for t in trigger_list if isitinburmese(t, word)), None)

def build_phrase(label, segments,start_seg, end_seg, join_ids):
    return {
        "clause": label,
        "word": "".join(segments[i]['word'] for i in join_ids),
        "start": start_seg["start"],
        "end": end_seg["end"],
        "join": sorted(join_ids)
    }

def collect_prev_by_type(segments, d, valid_groups, stop_groups, limit=3):
    collected = []
    for i in range(1, limit+1):
        prev = safe_prev(segments, d, i)
        if not prev:
            break
        if prev['entity_group'] in stop_groups:
            collected.append(prev)
            break
        if prev['entity_group'] not in valid_groups:
            break
        collected.append(prev)
    return collected[::-1]


def getfinals(segments):
  order = ["ကတ္တားပုဒ်","အသုံးခံပြပုဒ်","ယှဉ်တွဲပြပုဒ်","အကြောင်းပြပုဒ်","လိုက်လျောပြပုဒ်","နေရာပြပုဒ်","အချိန်ပြပုဒ်","နေရာဆက်တိုက်ပြပုဒ်","အချိန်ဆက်တိုက်ပြပုဒ်","ရှေးရူရာပြပုဒ်","ဆိုက်ရောက်ရာပြပုဒ်","ထွက်ခွာရာပြပုဒ်","လက်ခံပြပုဒ်","ပိုင်ဆိုင်ခြင်းပြပုဒ်","ရည်စူးချက်ပြပုဒ်","ခွဲထုတ်ရာပြပုဒ်","ကံပုဒ်"]
  verbs = ["ကြိယာဝိသေသနပုဒ်","ကြိယာပုဒ်"]
  reslist = defaultdict(list)
  for label in order:
    reslist[label] = getthelist([label])

  subjres = reslist["ကတ္တားပုဒ်"]
  #for "အသုံးခံပြပုဒ်" : ["အသုံးခံပြပုဒ်"]
  useres= reslist['အသုံးခံပြပုဒ်']
  #for "ယှဉ်တွဲပြပုဒ်" :["ယှဉ်တွဲပြပုဒ်"]
  joinres = reslist['ယှဉ်တွဲပြပုဒ်']
  #for "အကြောင်းပြပုဒ်":["အကြောင်းပြပုဒ်"]
  reasonres = reslist["အကြောင်းပြပုဒ်"]
  #for "လိုက်လျောပြပုဒ်" : ["လိုက်လျောပြပုဒ်"]
  agreeres = reslist["လိုက်လျောပြပုဒ်"]
  #for "အချိန်ပြပုဒ်" or "နေရာပြပုဒ်" : ["နေရာပြပုဒ်"]
  torpres = reslist["နေရာပြပုဒ်"]
  #for "အချိန်ဆက်တိုက်ပြပုဒ်" : ["အချိန်ဆက်တိုက်ပြပုဒ်"]
  tcontres = reslist["အချိန်ဆက်တိုက်ပြပုဒ်"]
  #for "နေရာဆက်တိုက်ပြပုဒ်" : ["နေရာဆက်တိုက်ပြပုဒ်"]
  pcontres = reslist["နေရာဆက်တိုက်ပြပုဒ်"]
  #for "ရှေးရူရာပြပုဒ်" : ["ရှေးရူရာပြပုဒ်"]
  towardres = reslist["ရှေးရူရာပြပုဒ်"]
  #for "ဆိုက်ရောက်ရာပြပုဒ်":["ဆိုက်ရောက်ရာပြပုဒ်"]
  arrivres = reslist["ဆိုက်ရောက်ရာပြပုဒ်"]
  #for "ထွက်ခွာရာပြပုဒ်" : ["ထွက်ခွာရာပြပုဒ်"]
  fromres = reslist["ထွက်ခွာရာပြပုဒ်"]
  #for "လက်ခံပြပုဒ်" :["လက်ခံပြပုဒ်"]
  recevres = reslist["လက်ခံပြပုဒ်"]
  #for "ပိုင်ဆိုင်ခြင်းပြပုဒ်" :["ပိုင်ဆိုင်ခြင်းပြပုဒ်"]
  ownerres = reslist["ပိုင်ဆိုင်ခြင်းပြပုဒ်"]
  #for "ရည်စူးချက်ပြပုဒ်" :["ရည်စူးချက်ပြပုဒ်"]
  aimres = reslist["ရည်စူးချက်ပြပုဒ်"]
  #for "ခွဲထုတ်ရာပြပုဒ်" :["ခွဲထုတ်ရာပြပုဒ်"]
  sepres = reslist["ခွဲထုတ်ရာပြပုဒ်"]
  #for "ကံပုဒ်":["ကံပုဒ်"]
  ores = reslist["ကံပုဒ်"]

  #for "ကြိယာပုဒ်" : ['ကြိယာဝိဘတ်','ဝါကျဆက်','ကြိယာပစ္စည်း']
  vdetect = ['ကြိယာဝိဘတ်','ဝါကျဆက်','ကြိယာပစ္စည်း']
  vres = getthelist(vdetect)

  phrases = []

  for d, seg in enumerate(segments):

      sign = None
      word = seg["word"].strip()
      ent  = seg["entity_group"]

      if ent not in lookfor and ent != "adv":
          continue

      prev1 = safe_prev(segments, d, 1)
      if not prev1:
          continue

      nprevs = collect_prev_by_type(segments, d, lookfor, {"n"})
      prevs  = collect_prev_by_type(segments, d, lookfor, {"v"})

      # -------------------
      # Adverb Clause
      # -------------------
      if ent == "adv":
          phrase = build_phrase("ကြိယာဝိသေသနပုဒ်", segments,seg, seg, [d])
          phrases.append(phrase)
          continue

      # -------------------
      # Subject
      # -------------------
      trigger = match_trigger(word, subjres)
      if trigger and nprevs and nprevs[0]['entity_group'] == 'n':

          join_ids = [segments.index(p) for p in nprevs] + [d]
          phrase = build_phrase("ကတ္တားပုဒ်",segments, nprevs[0], seg, join_ids)
          phrases.append(phrase)
          sign = "ကတ္တားပုဒ်"
          continue

      # -------------------
      # Simple Noun + Particle Patterns
      # -------------------
      patterns = [
          (useres,  "အသုံးခံပြပုဒ်"),
          (joinres,  "ယှဉ်တွဲပြပုဒ်"),
          (reasonres,"အကြောင်းပြပုဒ်"),
          (agreeres, "လိုက်လျောပြပုဒ်"),
          (torpres,  None),  # special handling
          (fromres,  "ထွက်ခွာရာပြပုဒ်"),
          (recevres, "လက်ခံပြပုဒ်"),
          (ownerres, "ပိုင်ဆိုင်ခြင်းပြပုဒ်"),
          (aimres,   "ရည်စူးချက်ပြပုဒ်"),
          (sepres,   "ခွဲထုတ်ရာပြပုဒ်"),
      ]

      for trigger_list, label in patterns:

          trigger = match_trigger(word, trigger_list)
          if not trigger:
              continue

          if prev1['entity_group'] == 'n':

              if trigger_list == torpres:
                  label = "အချိန်ပြပုဒ်" if trigger in timeps else "နေရာပြပုဒ်"

              phrase = build_phrase(label,segments, prev1, seg, [d-1, d])
              phrases.append(phrase)
              sign = label
              break
      #"နေရာဆက်တိုက်ပြပုဒ်","အချိန်ဆက်တိုက်ပြပုဒ်","ရှေးရူရာပြပုဒ်","ဆိုက်ရောက်ရာပြပုဒ်"
      trigger = match_trigger(word, tcontres)

      if trigger and prev1 and prev1['entity_group'] == 'n':
          if prev1['word'] in timeps:
              phrase = build_phrase("အချိန်ဆက်တိုက်ပြပုဒ်",segments, prev1, seg, [d-1, d])
              phrases.append(phrase)
              sign = "အချိန်ဆက်တိုက်ပြပုဒ်"
              continue

      trigger = match_trigger(word, tcontres)

      if trigger and prev1 and prev1['entity_group'] == 'n':
          if prev1['word'] not in timeps:
              phrase = build_phrase("နေရာဆက်တိုက်ပြပုဒ်",segments, prev1, seg, [d-1, d])
              phrases.append(phrase)
              sign = "နေရာဆက်တိုက်ပြပုဒ်"
              continue
      trigger = match_trigger(word, towardres)

      if trigger and prev1:

          closest_verb = None
          for a in range(d, len(segments)):
              if segments[a]['entity_group'] == 'v':
                  closest_verb = segments[a]
                  break

          if closest_verb and closest_verb['word'] in goverb:
              phrase = build_phrase("ရှေးရူရာပြပုဒ်",segments, prev1, seg, [d-1, d])
              phrases.append(phrase)
              sign = "ရှေးရူရာပြပုဒ်"
              continue
      trigger = match_trigger(word, arrivres)

      if trigger and prev1 and sign != "ရှေးရူရာပြပုဒ်":
          phrase = build_phrase("ဆိုက်ရောက်ရာပြပုဒ်", segments,prev1, seg, [d-1, d])
          phrases.append(phrase)
          sign = "ဆိုက်ရောက်ရာပြပုဒ်"
          continue
      if sign:
          continue

      # -------------------
      # Verb Clause
      # -------------------
      trigger = match_trigger(word, vres)
      if trigger and prevs:

          join_ids = [segments.index(p) for p in prevs] + [d]
          phrase = build_phrase("ကြိယာပုဒ်",segments, prevs[0], seg, join_ids)
          phrases.append(phrase)
          sign = "ကြိယာပုဒ်"
          continue

      # -------------------
      # Object Clause
      # -------------------
      trigger = match_trigger(word, ores)
      if trigger and prev1['entity_group'] != 'v':

          phrase = build_phrase("ကံပုဒ်",segments, prev1, seg, [d-1, d])
          phrases.append(phrase)
  return phrases


#@title raw wibet detection
#This session is detecting ပုဒ် with wibets , this is third and last part of my theory
def rawwibet(segments):
  order = ["ကြိယာဝိသေသနပုဒ်","ကတ္တားပုဒ်","အသုံးခံပြပုဒ်","ယှဉ်တွဲပြပုဒ်","အကြောင်းပြပုဒ်","လိုက်လျောပြပုဒ်","နေရာပြပုဒ်","အချိန်ပြပုဒ်","နေရာဆက်တိုက်ပြပုဒ်","အချိန်ဆက်တိုက်ပြပုဒ်","ရှေးရူရာပြပုဒ်","ဆိုက်ရောက်ရာပြပုဒ်","ထွက်ခွာရာပြပုဒ်","လက်ခံပြပုဒ်","ပိုင်ဆိုင်ခြင်းပြပုဒ်","ရည်စူးချက်ပြပုဒ်","ခွဲထုတ်ရာပြပုဒ်","ကြိယာပုဒ်","ကံပုဒ်"]

  #for "ကတ္တားပုဒ်" : ["ကတ္တားပုဒ်"]
  subjdetect = ["ကတ္တားပုဒ်"]
  subjres = getthelist(subjdetect)
  # print(subjres)
  #for "အသုံးခံပြပုဒ်" : ["အသုံးခံပြပုဒ်"]
  usedetect = ['အသုံးခံပြပုဒ်']
  useres = getthelist(usedetect)
  # print(useres)
  #for "ယှဉ်တွဲပြပုဒ်" :["ယှဉ်တွဲပြပုဒ်"]
  joindetect = ['ယှဉ်တွဲပြပုဒ်']
  joinres = getthelist(joindetect)
  # print(joinres)
  #for "အကြောင်းပြပုဒ်":["အကြောင်းပြပုဒ်"]
  reasondetect = ["အကြောင်းပြပုဒ်"]
  reasonres = getthelist(reasondetect)
  # print(reasonres)
  #for "လိုက်လျောပြပုဒ်" : ["လိုက်လျောပြပုဒ်"]
  agreedetect = ["လိုက်လျောပြပုဒ်"]
  agreeres = getthelist(agreedetect)
  # print(agreeres)
  #for "အချိန်ပြပုဒ်" or "နေရာပြပုဒ်" : ["နေရာပြပုဒ်"]
  torpdetect = ["နေရာပြပုဒ်"]
  torpres = getthelist(torpdetect)
  # print(torpres)
  #for "နေရာဆက်တိုက်ပြပုဒ်" : ["နေရာဆက်တိုက်ပြပုဒ်"]
  tcontdetect = ["နေရာဆက်တိုက်ပြပုဒ်"]
  tcontres = getthelist(tcontdetect)
  # print(tcontres)
  #for "အချိန်ဆက်တိုက်ပြပုဒ်" : ["အချိန်ဆက်တိုက်ပြပုဒ်"]
  pcontdetect = ["အချိန်ဆက်တိုက်ပြပုဒ်"]
  pcontres = getthelist(pcontdetect)
  # print(pcontres)
  #for "ရှေးရူရာပြပုဒ်" : ["ရှေးရူရာပြပုဒ်"]
  towardetect = ["ရှေးရူရာပြပုဒ်"]
  towardres = getthelist(towardetect)
  # print(towardres)
  #for "ဆိုက်ရောက်ရာပြပုဒ်":["ဆိုက်ရောက်ရာပြပုဒ်"]
  arrivdetect = ["ဆိုက်ရောက်ရာပြပုဒ်"]
  arrivres = getthelist(arrivdetect)
  # print(arrivres)
  #for "ထွက်ခွာရာပြပုဒ်" : ["ထွက်ခွာရာပြပုဒ်"]
  fromdetect = ["ထွက်ခွာရာပြပုဒ်"]
  fromres = getthelist(fromdetect)
  # print(fromres)
  #for "လက်ခံပြပုဒ်" :["လက်ခံပြပုဒ်"]
  recevdetect = ["လက်ခံပြပုဒ်"]
  recevres = getthelist(recevdetect)
  # print(recevres)
  #for "ပိုင်ဆိုင်ခြင်းပြပုဒ်" :["ပိုင်ဆိုင်ခြင်းပြပုဒ်"]
  ownerdetect = ["ပိုင်ဆိုင်ခြင်းပြပုဒ်"]
  ownerres =getthelist(ownerdetect)
  # print(ownerres)
  #for "ရည်စူးချက်ပြပုဒ်" :["ရည်စူးချက်ပြပုဒ်"]
  aimdetect = ["ရည်စူးချက်ပြပုဒ်"]
  aimres =getthelist(aimdetect)
  # print(aimres)
  #for "ခွဲထုတ်ရာပြပုဒ်" :["ခွဲထုတ်ရာပြပုဒ်"]
  sepdetect = ["ခွဲထုတ်ရာပြပုဒ်"]
  sepres =getthelist(sepdetect)
  # print(sepres)
  #for "ကြိယာပုဒ်" : ['ကြိယာဝိဘတ်','ဝါကျဆက်','ကြိယာပစ္စည်း']
  vdetect = ['ကြိယာဝိဘတ်','ဝါကျဆက်','ကြိယာပစ္စည်း']
  vres = getthelist(vdetect)
  # print(vres)
  #for "ကံပုဒ်":["ကံပုဒ်"]
  objdetect = ["ကံပုဒ်"]
  ores = getthelist(objdetect)
  # print(ores)

  phrases = []

  for d, seg in enumerate(segments):

      word = seg["word"].strip()
      ent = seg["entity_group"]

      if ent == "adv":
        phrase = jointwodict('clause',seg,None,"ကြိယာဝိသေသနပုဒ်")
        phrase['join']=[d]
        phrases.append(phrase)
        print(phrases)

      if ent not in lookfor:
          continue
      print("word is",word)
      count = 0
      nprevs = []
      for i in range(1,4):
        prev = safe_prev(segments,d,i)
        if not prev :
          break
        elif prev['entity_group'] == "n":
          nprevs.append(prev)
          break
        elif prev['entity_group'] not in lookfor:
          break
        nprevs.append(prev)
      nprevs=nprevs[::-1]
      print("subj",nprevs)
      prevs = []
      for i in range(1,4):
        prev = safe_prev(segments,d,i)
        if not prev :
          break
        elif prev['entity_group'] == "v":
          prevs.append(prev)
          break
        elif prev['entity_group'] not in lookfor:
          break
        prevs.append(prev)
      prevs=prevs[::-1]
      print("VP",prevs)

      prev1 = safe_prev(segments,d, 1)
      # prev2 = safe_prev(d, 2)

      sign = ''

      for trigger in subjres:
        if isitinburmese(trigger,word):
          print(trigger)
          phrase = {}
          if nprevs and nprevs[0]['entity_group'] == 'n':
            sign = 'ကတ္တားပုဒ်'
            phrase['join']=[]
            w = "".join(p['word'] for p in nprevs)+word

            last = nprevs[0]
            phrase["clause"] = sign
            phrase["word"] = w
            phrase["start"] = last["start"]
            phrase["end"] = seg["end"]
            for ind in range(len(nprevs)):
              index = d - ind -1
              print("this is",word,"and index is",index ,"ind is", ind )
              phrase['join'].append(index)
            phrase['join'].append(d)
            phrase['join'] = sorted(phrase['join'])
          # else:
          #  phrase = jointwodict('clause',seg,None,sign)
          #  phrase['join']=[d]
            phrases.append(phrase)
            print(phrases)
            count+=1
            break
      #Usage Detection
      for trigger in useres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1['entity_group'] == 'n':
            sign = "အသုံးခံပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrase['join'] = [d-1,d]
            phrases.append(phrase)
            count+=1
            break
      # Joint detection
      for trigger in joinres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1['entity_group'] == 'n':
            sign = "ယှဉ်တွဲပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrase['join'] = [d-1,d]
            phrases.append(phrase)
            count+=1
            break
      #Reason detection
      for trigger in reasonres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1['entity_group'] == 'n':
            sign = "အကြောင်းပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrase['join'] = [d-1,d]
            phrases.append(phrase)
            count+=1
            break
      #Agreement detection
      for trigger in agreeres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1['entity_group'] == 'n':
            sign = "လိုက်လျောပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrase['join'] = [d-1,d]
            phrases.append(phrase)
            count+=1
            break

      #time or place Detection
      for trigger in torpres:
        if isitinburmese(trigger,word):
          print(trigger)
          if trigger not in timeps:
            sign = "နေရာပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
          else:
            sign = "အချိန်ပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            # phrase['clause'] = sign
            # phrase['word'] = prev1['word']+word
            # phrase['start'] = prev1['start']
            # phrase['end'] = seg['end']
          phrase['join']=[d-1,d]
          phrases.append(phrase)
          print(phrases)
          count+=1
          break
      # time continuous detection
      for trigger in tcontres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1[word] in timeps:
            sign = "အချိန်ဆက်တိုက်ပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)

            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break
      # place continuous detection
      if sign != "အချိန်ဆက်တိုက်ပြပုဒ်":
        for trigger in tcontres:
          if isitinburmese(trigger,word):
            print(trigger)
            sign = "နေရာဆက်တိုက်ပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)

            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break
      #Toward detection
      for trigger in towardres:
        if isitinburmese(trigger,word):
          print(trigger)
          #get the closet verb
          for a in range(d,len(segments)):
            if segments[a]['entity_group'] == 'v':
              clostverb = segments[a]
              break

          if clostverb[word] in goverb:
            sign = "ရှေးရူရာပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break
      #Arrival detection
      if sign != "ရှေးရူရာပြပုဒ်":
        for trigger in tcontres:
          if isitinburmese(trigger,word):
            print(trigger)
            sign = "ဆိုက်ရောက်ရာပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)

            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break
      #From Detection
      for trigger in fromres:
        if isitinburmese(trigger,word):
          print(trigger)
          sign = "ထွက်ခွာရာပြပုဒ်"
          phrase = jointwodict('clause',prev1,seg,sign)

          phrases.append(phrase)
          phrase['join']=[d-1,d]
          print(phrases)
          count+=1
          break
      #Receiver Detection
      for trigger in recevres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1['entity_group'] == 'n':
            sign = "လက်ခံပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break
      #Owner Detection
      for trigger in ownerres:
        if isitinburmese(trigger,word):
          print(trigger)
          if prev1['entity_group'] == 'n':
            sign = "ပိုင်ဆိုင်ခြင်းပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)
            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break

      #Aim Detection
      for trigger in aimres:
        if isitinburmese(trigger,word):
          print(trigger)
          if 'n' in prev1['entity_group']:
            sign = "ရည်စူးချက်ပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)

            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break

      #Aim Detection
      for trigger in sepres:
        if isitinburmese(trigger,word):
          print(trigger)
          if 'n' in prev1['entity_group']:
            sign = "ခွဲထုတ်ရာပြပုဒ်"
            phrase = jointwodict('clause',prev1,seg,sign)

            phrases.append(phrase)
            phrase['join']=[d-1,d]
            print(phrases)
            count+=1
            break

      # Verb Clause Detection
      if sign != "ကတ္တားပုဒ်":
        for trigger in vres:
            if isitinburmese(trigger,word):
                print(trigger)
                phrase = {}
                if prevs:
                  sign = 'ကြိယာပုဒ်'
                  phrase['join']=[]
                  w = "".join(p['word'] for p in prevs)+word

                  last = prevs[0]
                  phrase["clause"] = "ကြိယာပုဒ်"
                  phrase["word"] = w
                  phrase["start"] = last["start"]
                  phrase["end"] = seg["end"]
                  for ind in range(len(prevs)):
                    index = d - ind -1
                    print("this is",word,"and index is",index ,"ind is", ind )
                    phrase['join'].append(index)
                  phrase['join'].append(d)
                  phrase['join'] = sorted(phrase['join'])
                # else:
                #  phrase = jointwodict('clause',seg,None,sign)
                #  phrase['join']=[d]
                  phrases.append(phrase)
                  print(phrases)
                  count+=1
                  break

      # -------------------
      # ✅ Object Clause Detection
      # -------------------
      for trigger in ores:

          if isitinburmese(trigger,word):
              print(trigger)
              phrase = {}

              if prev1 and prev1["entity_group"] != "v":

                  phrase = jointwodict('clause',prev1,seg,"ကံပုဒ်")

              if sign:
                for _ in range(count):
                  phrases.pop()
              phrase['join']=[d-1,d]
              phrases.append(phrase)

              break

  return phrases

#@title Validation of phrases
#fix the phrase where they can be overlapped
def validatephrase(phrases,segments):
  joined = [i['join'] for i in phrases]
  # print(joined)
  prev = []
  for d,i in enumerate(joined):
    interset = list(set(prev) & set(i))
    prev = i
    # print(interset)
    if interset:
      if phrases[d]['clause'] == phrases[d-1]['clause']:
        word = ''
        for j in i:
          word += segments[j]['word']
        phrase = {}
        phrase['clause'] = phrases[d]['clause']
        phrase['word'] = word
        phrase['start'] = phrases[d-1]['start']
        phrase['end'] = phrases[d]['end']
        phrase['join'] = phrases[d]['join']
        phrases.pop(d)
        phrases.pop(d-1)
        phrases.append(phrase)
  return phrases

#@title fill the gap
#Original sentence and the phrase
def fillthegap(phrases,segments):
  phs = [i['clause'] for i in phrases]
  joined = [i['join'] for i in phrases]
  joined = list(set([I for sub in joined for I in sub]))
  if len(joined) != len(segments):
    nphrases = []
    j = 0
    for i in range(len(segments)):
      if i not in joined:
        sign = 'အဖြည့်ပုဒ်'
        if i == 0 and segments[i]['entity_group']=='n' and "ကတ္တားပုဒ်" not in phs:
          sign = "ကတ္တားပုဒ်"
        elif i ==len(segments)-1 and "ကြိယာပုဒ်" not in phs:
          sign = "ကြိယာပုဒ်"
        nphrase = jointwodict('clause', segments[i],None,sign)
        nphrase['join'] = [i]
        nphrases.append(nphrase)
        continue
      # nphrases.append(phrases[j])
    nphrases = nphrases+phrases
    nphrases= sorted(nphrases,key =lambda x:x['start'])
    return nphrases
  else:
    return phrases

#@title Reconstruct
def reconstruct(subsentences):
    temp = []
    phrases = []

    for i in subsentences:
        # If there is a connector (joint) to the next clause
        if i['joint']:
            joint_word = i['joint']['word']

            # Update the last word of the sentence and phrase list
            # We replace the sentence-ending 'thi' with the connector
            i['sentence'][-1]['word'] = i['sentence'][-1]['word'].replace("သည်။", joint_word)
            i['sentence'][-1]['end'] = i['joint']['end']
            i['phrases'][-1]['word'] = i['phrases'][-1]['word'].replace("သည်။", joint_word)
            i['phrases'][-1]['end'] = i['joint']['end']

        # Flatten the sentence tokens
        for j in i['sentence']:
            temp.append(j)

        # Flatten the phrases
        for j in i['phrases']:
            phrases.append(j)

    return temp, phrases

# @title Input Area
# sentence = "ထိုအလင်းတန်းကို ထောင့်မတ်ကျဖြတ်၍သွားသော ခါးပတ် ပေါ်တွင် သယ်ဆောင်သော ပစ္စည်းများကို ထား၏။"
# sentence = "ဆရာ စာသင်သောအခါကျွန်တော်နှင့်မောင်မောင်တို့သည်ဂရုတစိုက်နားထောင်မှတ်သားကြသည်။"
# sentence = "ဤနေရာသည်ကောင်းခြင်းနှင့်ပြည့်စုံပေ၏။"
# sentence = "ငါးတစ်ကောင်ဖမ်းမိသည်။"
# sentence = "ဒရယ်ဖိုတစ်ကောင်လုံးကိုစားလိုက်သည်။"
# sentence = "လူကလေးများကစားနေကြသည်။"
# sentence = "လှပ စွာ လျှောက်လှမ်းလာသောသူအားတွေ့သည်။"
# sentence = "ပန်းများသည်ရာသီအလိုက်ဖူးပွင့်ကြသည်။"
# sentence = "မောင်မောင်အတွက်လက်ဆောင်ဝယ်လာသည်။"
# sentence = sentence.replace(" ","")
def model(sentence):
  sentence = normalize_unicode(sentence)
  print(sentence)
  segments = pos(sentence)
  print("model-tagged input")
  display(segments,"entity_group")
  segments = validate(segments)
  print("Validated")
  display(segments,'entity_group')
  # display(segments)
  temp = Pisi(segments)
  print('Pisi')
  display(temp)

  subsentences = GetSentences(temp)

  for _ in subsentences:
    print('subs')

    _['sentence'] = adjtoN(_['sentence'])
    print('adj+n')
    display(_['sentence'])
    _['phrases'] = rawwibet(_['sentence'])
    print("wibet")
    display(_['phrases'],'clause')
    _['phrases'] = validatephrase(_['phrases'], _['sentence'])
    print('Valide phrases')
    display(_['phrases'],'clause')
    _['phrases'] = fillthegap(_['phrases'],_['sentence'])
    print('fillthegap')
    display(_['phrases'],'clause')

  segments,phrases = reconstruct(subsentences)
  print("Result")
  display(segments)
  display(phrases,'clause')
  return segments, phrases